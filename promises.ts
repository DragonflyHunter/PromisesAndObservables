///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Basic case of Promise/Then/Catch
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// new Promise<number>((resolve, reject) => {
//     setTimeout(() => {
//         if (Date.now() % 2 === 1)
//             resolve(1);
//         else    
//             reject(0);
//     }, 1000);
// })
// .then(d => console.log("resolved with: " + d))
// .catch(d => console.log("rejected with: " + d));

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Promise/Then/Catch are async
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// let p = new Promise<number>((resolve, reject) => {
//     if (Date.now() % 2 === 1)
//         resolve(1);
//     else    
//         reject(0);
// }).then(d => console.log("resolved with: " + d)).catch(d => console.log("rejected with: " + d));
// console.log("After promise.");

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Then modifies output
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// new Promise<number>((resolve) => {
//     var f = () => setTimeout(() => {resolve(1);}, 15000);
//     f();
//     console.log("Inside Promise Constructor");
// })
// .then<string>(d => { return "Sean";})
// .then((d) => console.log("resolved with: " + d));

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Then is async and will wait for any new promises returned by previous thens.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// new Promise<number>((resolve) => {
//     resolve(1);
// })
// .then(d => d+1)
// .then(d => new Promise((resolve) => {setTimeout(() => resolve(++d), 1000)}))
// .then(d => console.log("resolved with: " + d));

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Nested promise thens are respected too
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// new Promise<number>((resolve) => {
//     resolve(1);
// })
// .then(d => d+1)
// .then(d => new Promise<number>((resolve) => setTimeout(() => resolve(d), 1000)).then(d => d+1))
// .then(d => console.log("resolved with: " + d));

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// What will this return?
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// new Promise<number>((resolve) => {
//     resolve(1);
// })
// .then(d => d+1)
// .then(d => setTimeout(() => d+1, 1000))
// .then(d => console.log("resolved with: " + d));

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Branching promises
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// var p = new Promise<number>((resolve) => {
//     resolve(1);
// });
// p.then(d => d+1).then(d => console.log("1st resolved with: " + d));
// p.then(d => d+1).then(d => console.log("2nd resolved with: " + d));
// p.then(d => console.log("3rd resolved with: " + d));


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Branching promises during creation and after
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// var f = (): Promise<number> => {
//     var p = new Promise<number>((resolve) => {
//         resolve(1);
//     });
//     p.then(d => d+1);
//     return p;
// };
// var p = f();
// p.then(d => console.log("1st resolved with: " + d));
// p.then(d => d+1)
//     .then(d => console.log("2nd resolved with: " + d));
// p.then(d => console.log("3rd resolved with: " + d));

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Returning a different type from a then clause
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// var getData = (): Promise<string> => {
//     return new Promise<number>((resolve) => {
//         resolve(10);
//     })
//     .then(d => (d*500000).toString());
// };

// var p = getData();
// p.then(d => console.log("Resolved with: " + d));


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// What does this do?
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// var f = () => ({});
// new Promise<number>((resolve, reject) => {
//     resolve(1);
// })
// .then(d => f())
// .then(d => console.log("resolved with: " + d));

